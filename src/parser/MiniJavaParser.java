package parser;

/* MiniJavaParser.java */
/* Generated By:JavaCC: Do not edit this line. MiniJavaParser.java */
import syntaxtree.*;
import java.util.Vector;


public class MiniJavaParser implements MiniJavaParserConstants {

  final public Goal Goal() throws ParseException {MainClass n0;
   NodeListOptional n1 = new NodeListOptional();
   ClassDeclaration n2;
   NodeToken n3;
   Token n4;
    n0 = MainClass();
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case CLASS:{
        ;
        break;
        }
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      n2 = ClassDeclaration();
n1.addNode(n2);
    }
n1.nodes.trimToSize();
    n4 = jj_consume_token(0);
n4.beginColumn++; n4.endColumn++;
      n3 = JTBToolkit.makeNodeToken(n4);
{if ("" != null) return new Goal(n0,n1,n3);}
    throw new Error("Missing return statement in function");
}

  final public MainClass MainClass() throws ParseException {NodeToken n0;
   Token n1;
   Identifier n2;
   NodeToken n3;
   Token n4;
   NodeToken n5;
   Token n6;
   NodeToken n7;
   Token n8;
   NodeToken n9;
   Token n10;
   NodeToken n11;
   Token n12;
   NodeToken n13;
   Token n14;
   NodeToken n15;
   Token n16;
   NodeToken n17;
   Token n18;
   NodeToken n19;
   Token n20;
   Identifier n21;
   NodeToken n22;
   Token n23;
   NodeToken n24;
   Token n25;
   Statement n26;
   NodeToken n27;
   Token n28;
   NodeToken n29;
   Token n30;
    n1 = jj_consume_token(CLASS);
n0 = JTBToolkit.makeNodeToken(n1);
    n2 = Identifier();
    n4 = jj_consume_token(LBRACE);
n3 = JTBToolkit.makeNodeToken(n4);
    n6 = jj_consume_token(PUBLIC);
n5 = JTBToolkit.makeNodeToken(n6);
    n8 = jj_consume_token(STATIC);
n7 = JTBToolkit.makeNodeToken(n8);
    n10 = jj_consume_token(VOID);
n9 = JTBToolkit.makeNodeToken(n10);
    n12 = jj_consume_token(MAIN);
n11 = JTBToolkit.makeNodeToken(n12);
    n14 = jj_consume_token(LPAREN);
n13 = JTBToolkit.makeNodeToken(n14);
    n16 = jj_consume_token(STRING);
n15 = JTBToolkit.makeNodeToken(n16);
    n18 = jj_consume_token(32);
n17 = JTBToolkit.makeNodeToken(n18);
    n20 = jj_consume_token(33);
n19 = JTBToolkit.makeNodeToken(n20);
    n21 = Identifier();
    n23 = jj_consume_token(RPAREN);
n22 = JTBToolkit.makeNodeToken(n23);
    n25 = jj_consume_token(LBRACE);
n24 = JTBToolkit.makeNodeToken(n25);
    n26 = Statement();
    n28 = jj_consume_token(RBRACE);
n27 = JTBToolkit.makeNodeToken(n28);
    n30 = jj_consume_token(RBRACE);
n29 = JTBToolkit.makeNodeToken(n30);
{if ("" != null) return new MainClass(n0,n2,n3,n5,n7,n9,n11,n13,n15,n17,n19,n21,n22,n24,n26,n27,n29);}
    throw new Error("Missing return statement in function");
}

  final public ClassDeclaration ClassDeclaration() throws ParseException {NodeToken n0;
   Token n1;
   Identifier n2;
   NodeOptional n3 = new NodeOptional();
   NodeSequence n4;
   NodeToken n5;
   Token n6;
   Identifier n7;
   NodeToken n8;
   Token n9;
   NodeListOptional n10 = new NodeListOptional();
   VarDeclaration n11;
   NodeListOptional n12 = new NodeListOptional();
   MethodDeclaration n13;
   NodeToken n14;
   Token n15;
    n1 = jj_consume_token(CLASS);
n0 = JTBToolkit.makeNodeToken(n1);
    n2 = Identifier();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case EXTENDS:{
n4 = new NodeSequence(2);
      n6 = jj_consume_token(EXTENDS);
n5 = JTBToolkit.makeNodeToken(n6);
n4.addNode(n5);
      n7 = Identifier();
n4.addNode(n7);
n3.addNode(n4);
      break;
      }
    default:
      jj_la1[1] = jj_gen;
      ;
    }
    n9 = jj_consume_token(LBRACE);
n8 = JTBToolkit.makeNodeToken(n9);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case TYPE_INT:
      case TYPE_BOOL:
      case IDENTIFIER:{
        ;
        break;
        }
      default:
        jj_la1[2] = jj_gen;
        break label_2;
      }
      n11 = VarDeclaration();
n10.addNode(n11);
    }
n10.nodes.trimToSize();
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PUBLIC:{
        ;
        break;
        }
      default:
        jj_la1[3] = jj_gen;
        break label_3;
      }
      n13 = MethodDeclaration();
n12.addNode(n13);
    }
n12.nodes.trimToSize();
    n15 = jj_consume_token(RBRACE);
n14 = JTBToolkit.makeNodeToken(n15);
{if ("" != null) return new ClassDeclaration(n0,n2,n3,n8,n10,n12,n14);}
    throw new Error("Missing return statement in function");
}

  final public MethodDeclaration MethodDeclaration() throws ParseException {NodeToken n0;
   Token n1;
   Type n2;
   Identifier n3;
   NodeToken n4;
   Token n5;
   NodeOptional n6 = new NodeOptional();
   NodeSequence n7;
   Type n8;
   Identifier n9;
   NodeListOptional n10;
   NodeSequence n11;
   NodeToken n12;
   Token n13;
   Type n14;
   Identifier n15;
   NodeToken n16;
   Token n17;
   NodeToken n18;
   Token n19;
   NodeListOptional n20 = new NodeListOptional();
   VarDeclaration n21;
   NodeListOptional n22 = new NodeListOptional();
   Statement n23;
   NodeToken n24;
   Token n25;
   Expression n26;
   NodeToken n27;
   Token n28;
   NodeToken n29;
   Token n30;
    n1 = jj_consume_token(PUBLIC);
n0 = JTBToolkit.makeNodeToken(n1);
    n2 = Type();
    n3 = Identifier();
    n5 = jj_consume_token(LPAREN);
n4 = JTBToolkit.makeNodeToken(n5);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case TYPE_INT:
    case TYPE_BOOL:
    case IDENTIFIER:{
n10 = new NodeListOptional();
n7 = new NodeSequence(3);
      n8 = Type();
n7.addNode(n8);
      n9 = Identifier();
n7.addNode(n9);
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 34:{
          ;
          break;
          }
        default:
          jj_la1[4] = jj_gen;
          break label_4;
        }
n11 = new NodeSequence(3);
        n13 = jj_consume_token(34);
n12 = JTBToolkit.makeNodeToken(n13);
n11.addNode(n12);
        n14 = Type();
n11.addNode(n14);
        n15 = Identifier();
n11.addNode(n15);
n10.addNode(n11);
      }
n10.nodes.trimToSize();
n7.addNode(n10);
n6.addNode(n7);
      break;
      }
    default:
      jj_la1[5] = jj_gen;
      ;
    }
    n17 = jj_consume_token(RPAREN);
n16 = JTBToolkit.makeNodeToken(n17);
    n19 = jj_consume_token(LBRACE);
n18 = JTBToolkit.makeNodeToken(n19);
    label_5:
    while (true) {
      if (jj_2_1(2)) {
        ;
      } else {
        break label_5;
      }
      n21 = VarDeclaration();
n20.addNode(n21);
    }
n20.nodes.trimToSize();
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LBRACE:
      case IF:
      case WHILE:
      case PRINT:
      case IDENTIFIER:{
        ;
        break;
        }
      default:
        jj_la1[6] = jj_gen;
        break label_6;
      }
      n23 = Statement();
n22.addNode(n23);
    }
n22.nodes.trimToSize();
    n25 = jj_consume_token(RETURN);
n24 = JTBToolkit.makeNodeToken(n25);
    n26 = Expression();
    n28 = jj_consume_token(35);
n27 = JTBToolkit.makeNodeToken(n28);
    n30 = jj_consume_token(RBRACE);
n29 = JTBToolkit.makeNodeToken(n30);
{if ("" != null) return new MethodDeclaration(n0,n2,n3,n4,n6,n16,n18,n20,n22,n24,n26,n27,n29);}
    throw new Error("Missing return statement in function");
}

  final public VarDeclaration VarDeclaration() throws ParseException {Type n0;
   Identifier n1;
   NodeToken n2;
   Token n3;
    n0 = Type();
    n1 = Identifier();
    n3 = jj_consume_token(35);
n2 = JTBToolkit.makeNodeToken(n3);
{if ("" != null) return new VarDeclaration(n0,n1,n2);}
    throw new Error("Missing return statement in function");
}

  final public Type Type() throws ParseException {NodeChoice n0;
   NodeSequence n1;
   NodeToken n2;
   Token n3;
   NodeOptional n4 = new NodeOptional();
   NodeSequence n5;
   NodeToken n6;
   Token n7;
   NodeToken n8;
   Token n9;
   NodeToken n10;
   Token n11;
   Identifier n12;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case TYPE_INT:{
n1 = new NodeSequence(2);
      n3 = jj_consume_token(TYPE_INT);
n2 = JTBToolkit.makeNodeToken(n3);
n1.addNode(n2);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 32:{
n5 = new NodeSequence(2);
        n7 = jj_consume_token(32);
n6 = JTBToolkit.makeNodeToken(n7);
n5.addNode(n6);
        n9 = jj_consume_token(33);
n8 = JTBToolkit.makeNodeToken(n9);
n5.addNode(n8);
n4.addNode(n5);
        break;
        }
      default:
        jj_la1[7] = jj_gen;
        ;
      }
n1.addNode(n4);
n0 = new NodeChoice(n1, 0);
      break;
      }
    case TYPE_BOOL:{
      n11 = jj_consume_token(TYPE_BOOL);
n10 = JTBToolkit.makeNodeToken(n11);
n0 = new NodeChoice(n10, 1);
      break;
      }
    case IDENTIFIER:{
      n12 = Identifier();
n0 = new NodeChoice(n12, 2);
      break;
      }
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return new Type(n0);}
    throw new Error("Missing return statement in function");
}

  final public Statement Statement() throws ParseException {NodeChoice n0;
   NodeSequence n1;
   NodeToken n2;
   Token n3;
   NodeListOptional n4 = new NodeListOptional();
   Statement n5;
   NodeToken n6;
   Token n7;
   NodeSequence n8;
   NodeToken n9;
   Token n10;
   NodeToken n11;
   Token n12;
   Expression n13;
   NodeToken n14;
   Token n15;
   Statement n16;
   NodeToken n17;
   Token n18;
   Statement n19;
   NodeSequence n20;
   NodeToken n21;
   Token n22;
   NodeToken n23;
   Token n24;
   Expression n25;
   NodeToken n26;
   Token n27;
   Statement n28;
   NodeSequence n29;
   NodeToken n30;
   Token n31;
   NodeToken n32;
   Token n33;
   Expression n34;
   NodeToken n35;
   Token n36;
   NodeToken n37;
   Token n38;
   NodeSequence n39;
   Identifier n40;
   NodeOptional n41 = new NodeOptional();
   NodeSequence n42;
   NodeToken n43;
   Token n44;
   Expression n45;
   NodeToken n46;
   Token n47;
   NodeToken n48;
   Token n49;
   Expression n50;
   NodeToken n51;
   Token n52;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LBRACE:{
n1 = new NodeSequence(3);
      n3 = jj_consume_token(LBRACE);
n2 = JTBToolkit.makeNodeToken(n3);
n1.addNode(n2);
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case LBRACE:
        case IF:
        case WHILE:
        case PRINT:
        case IDENTIFIER:{
          ;
          break;
          }
        default:
          jj_la1[9] = jj_gen;
          break label_7;
        }
        n5 = Statement();
n4.addNode(n5);
      }
n4.nodes.trimToSize();
n1.addNode(n4);
      n7 = jj_consume_token(RBRACE);
n6 = JTBToolkit.makeNodeToken(n7);
n1.addNode(n6);
n0 = new NodeChoice(n1, 0);
      break;
      }
    case IF:{
n8 = new NodeSequence(7);
      n10 = jj_consume_token(IF);
n9 = JTBToolkit.makeNodeToken(n10);
n8.addNode(n9);
      n12 = jj_consume_token(LPAREN);
n11 = JTBToolkit.makeNodeToken(n12);
n8.addNode(n11);
      n13 = Expression();
n8.addNode(n13);
      n15 = jj_consume_token(RPAREN);
n14 = JTBToolkit.makeNodeToken(n15);
n8.addNode(n14);
      n16 = Statement();
n8.addNode(n16);
      n18 = jj_consume_token(ELSE);
n17 = JTBToolkit.makeNodeToken(n18);
n8.addNode(n17);
      n19 = Statement();
n8.addNode(n19);
n0 = new NodeChoice(n8, 1);
      break;
      }
    case WHILE:{
n20 = new NodeSequence(5);
      n22 = jj_consume_token(WHILE);
n21 = JTBToolkit.makeNodeToken(n22);
n20.addNode(n21);
      n24 = jj_consume_token(LPAREN);
n23 = JTBToolkit.makeNodeToken(n24);
n20.addNode(n23);
      n25 = Expression();
n20.addNode(n25);
      n27 = jj_consume_token(RPAREN);
n26 = JTBToolkit.makeNodeToken(n27);
n20.addNode(n26);
      n28 = Statement();
n20.addNode(n28);
n0 = new NodeChoice(n20, 2);
      break;
      }
    case PRINT:{
n29 = new NodeSequence(5);
      n31 = jj_consume_token(PRINT);
n30 = JTBToolkit.makeNodeToken(n31);
n29.addNode(n30);
      n33 = jj_consume_token(LPAREN);
n32 = JTBToolkit.makeNodeToken(n33);
n29.addNode(n32);
      n34 = Expression();
n29.addNode(n34);
      n36 = jj_consume_token(RPAREN);
n35 = JTBToolkit.makeNodeToken(n36);
n29.addNode(n35);
      n38 = jj_consume_token(35);
n37 = JTBToolkit.makeNodeToken(n38);
n29.addNode(n37);
n0 = new NodeChoice(n29, 3);
      break;
      }
    case IDENTIFIER:{
n39 = new NodeSequence(5);
      n40 = Identifier();
n39.addNode(n40);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 32:{
n42 = new NodeSequence(3);
        n44 = jj_consume_token(32);
n43 = JTBToolkit.makeNodeToken(n44);
n42.addNode(n43);
        n45 = Expression();
n42.addNode(n45);
        n47 = jj_consume_token(33);
n46 = JTBToolkit.makeNodeToken(n47);
n42.addNode(n46);
n41.addNode(n42);
        break;
        }
      default:
        jj_la1[10] = jj_gen;
        ;
      }
n39.addNode(n41);
      n49 = jj_consume_token(36);
n48 = JTBToolkit.makeNodeToken(n49);
n39.addNode(n48);
      n50 = Expression();
n39.addNode(n50);
      n52 = jj_consume_token(35);
n51 = JTBToolkit.makeNodeToken(n52);
n39.addNode(n51);
n0 = new NodeChoice(n39, 4);
      break;
      }
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return new Statement(n0);}
    throw new Error("Missing return statement in function");
}

  final public Expression Expression() throws ParseException {NodeChoice n0;
   NodeSequence n1;
   NodeToken n2;
   Token n3;
   NodeChoice n4;
   NodeSequence n5;
   NodeToken n6;
   Token n7;
   NodeToken n8;
   Token n9;
   Expression n10;
   NodeToken n11;
   Token n12;
   NodeSequence n13;
   Identifier n14;
   NodeToken n15;
   Token n16;
   NodeToken n17;
   Token n18;
   NodeToken n19;
   Token n20;
   NodeToken n21;
   Token n22;
   Identifier n23;
   NodeToken n24;
   Token n25;
   NodeSequence n26;
   NodeToken n27;
   Token n28;
   Expression n29;
   NodeSequence n30;
   NodeToken n31;
   Token n32;
   Expression n33;
   NodeToken n34;
   Token n35;
   NodeListOptional n36 = new NodeListOptional();
   NodeChoice n37;
   NodeSequence n38;
   NodeToken n39;
   Token n40;
   NodeChoice n41;
   NodeToken n42;
   Token n43;
   NodeSequence n44;
   Identifier n45;
   NodeToken n46;
   Token n47;
   NodeOptional n48;
   NodeSequence n49;
   Expression n50;
   NodeListOptional n51;
   NodeSequence n52;
   NodeToken n53;
   Token n54;
   Expression n55;
   NodeToken n56;
   Token n57;
   NodeSequence n58;
   NodeToken n59;
   Token n60;
   Expression n61;
   NodeToken n62;
   Token n63;
   NodeSequence n64;
   NodeToken n65;
   Token n66;
   Expression n67;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NEW:{
n1 = new NodeSequence(2);
      n3 = jj_consume_token(NEW);
n2 = JTBToolkit.makeNodeToken(n3);
n1.addNode(n2);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case TYPE_INT:{
n5 = new NodeSequence(4);
        n7 = jj_consume_token(TYPE_INT);
n6 = JTBToolkit.makeNodeToken(n7);
n5.addNode(n6);
        n9 = jj_consume_token(32);
n8 = JTBToolkit.makeNodeToken(n9);
n5.addNode(n8);
        n10 = Expression();
n5.addNode(n10);
        n12 = jj_consume_token(33);
n11 = JTBToolkit.makeNodeToken(n12);
n5.addNode(n11);
n4 = new NodeChoice(n5, 0);
        break;
        }
      case IDENTIFIER:{
n13 = new NodeSequence(3);
        n14 = Identifier();
n13.addNode(n14);
        n16 = jj_consume_token(LPAREN);
n15 = JTBToolkit.makeNodeToken(n16);
n13.addNode(n15);
        n18 = jj_consume_token(RPAREN);
n17 = JTBToolkit.makeNodeToken(n18);
n13.addNode(n17);
n4 = new NodeChoice(n13, 1);
        break;
        }
      default:
        jj_la1[12] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
n1.addNode(n4);
n0 = new NodeChoice(n1, 0);
      break;
      }
    case INTEGER_LITERAL:{
      n20 = jj_consume_token(INTEGER_LITERAL);
n19 = JTBToolkit.makeNodeToken(n20);
n0 = new NodeChoice(n19, 1);
      break;
      }
    case BOOLEAN_LITERAL:{
      n22 = jj_consume_token(BOOLEAN_LITERAL);
n21 = JTBToolkit.makeNodeToken(n22);
n0 = new NodeChoice(n21, 2);
      break;
      }
    case IDENTIFIER:{
      n23 = Identifier();
n0 = new NodeChoice(n23, 3);
      break;
      }
    case THIS:{
      n25 = jj_consume_token(THIS);
n24 = JTBToolkit.makeNodeToken(n25);
n0 = new NodeChoice(n24, 4);
      break;
      }
    case 37:{
n26 = new NodeSequence(2);
      n28 = jj_consume_token(37);
n27 = JTBToolkit.makeNodeToken(n28);
n26.addNode(n27);
      n29 = Expression();
n26.addNode(n29);
n0 = new NodeChoice(n26, 5);
      break;
      }
    case LPAREN:{
n30 = new NodeSequence(3);
      n32 = jj_consume_token(LPAREN);
n31 = JTBToolkit.makeNodeToken(n32);
n30.addNode(n31);
      n33 = Expression();
n30.addNode(n33);
      n35 = jj_consume_token(RPAREN);
n34 = JTBToolkit.makeNodeToken(n35);
n30.addNode(n34);
n0 = new NodeChoice(n30, 6);
      break;
      }
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_8:
    while (true) {
      if (jj_2_2(2)) {
        ;
      } else {
        break label_8;
      }
n48 = new NodeOptional();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 38:{
n38 = new NodeSequence(2);
        n40 = jj_consume_token(38);
n39 = JTBToolkit.makeNodeToken(n40);
n38.addNode(n39);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case LENGTH:{
          n43 = jj_consume_token(LENGTH);
n42 = JTBToolkit.makeNodeToken(n43);
n41 = new NodeChoice(n42, 0);
          break;
          }
        case IDENTIFIER:{
n44 = new NodeSequence(4);
          n45 = Identifier();
n44.addNode(n45);
          n47 = jj_consume_token(LPAREN);
n46 = JTBToolkit.makeNodeToken(n47);
n44.addNode(n46);
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case LPAREN:
          case NEW:
          case THIS:
          case INTEGER_LITERAL:
          case BOOLEAN_LITERAL:
          case IDENTIFIER:
          case 37:{
n51 = new NodeListOptional();
n49 = new NodeSequence(2);
            n50 = Expression();
n49.addNode(n50);
            label_9:
            while (true) {
              switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
              case 34:{
                ;
                break;
                }
              default:
                jj_la1[14] = jj_gen;
                break label_9;
              }
n52 = new NodeSequence(2);
              n54 = jj_consume_token(34);
n53 = JTBToolkit.makeNodeToken(n54);
n52.addNode(n53);
              n55 = Expression();
n52.addNode(n55);
n51.addNode(n52);
            }
n51.nodes.trimToSize();
n49.addNode(n51);
n48.addNode(n49);
            break;
            }
          default:
            jj_la1[15] = jj_gen;
            ;
          }
n44.addNode(n48);
          n57 = jj_consume_token(RPAREN);
n56 = JTBToolkit.makeNodeToken(n57);
n44.addNode(n56);
n41 = new NodeChoice(n44, 1);
          break;
          }
        default:
          jj_la1[16] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
n38.addNode(n41);
n37 = new NodeChoice(n38, 0);
        break;
        }
      case 32:{
n58 = new NodeSequence(3);
        n60 = jj_consume_token(32);
n59 = JTBToolkit.makeNodeToken(n60);
n58.addNode(n59);
        n61 = Expression();
n58.addNode(n61);
        n63 = jj_consume_token(33);
n62 = JTBToolkit.makeNodeToken(n63);
n58.addNode(n62);
n37 = new NodeChoice(n58, 1);
        break;
        }
      case OPERATOR:{
n64 = new NodeSequence(2);
        n66 = jj_consume_token(OPERATOR);
n65 = JTBToolkit.makeNodeToken(n66);
n64.addNode(n65);
        n67 = Expression();
n64.addNode(n67);
n37 = new NodeChoice(n64, 2);
        break;
        }
      default:
        jj_la1[17] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
n36.addNode(n37);
    }
n36.nodes.trimToSize();
{if ("" != null) return new Expression(n0,n36);}
    throw new Error("Missing return statement in function");
}

  final public Identifier Identifier() throws ParseException {NodeToken n0;
   Token n1;
    n1 = jj_consume_token(IDENTIFIER);
n0 = JTBToolkit.makeNodeToken(n1);
{if ("" != null) return new Identifier(n0);}
    throw new Error("Missing return statement in function");
}

  private boolean jj_2_1(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_1()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_2()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_3_2()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_Expression_654_13_11()) {
    jj_scanpos = xsp;
    if (jj_3R_Expression_700_13_12()) {
    jj_scanpos = xsp;
    if (jj_3R_Expression_712_13_13()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_Type_317_7_19()
 {
    if (jj_scan_token(TYPE_INT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_Type_322_13_29()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_Identifier_739_4_15()
 {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_Type_316_4_14()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_Type_317_7_19()) {
    jj_scanpos = xsp;
    if (jj_3R_Type_334_7_20()) {
    jj_scanpos = xsp;
    if (jj_3R_Type_337_7_21()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_Expression_635_10_28()
 {
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3_1()
 {
    if (jj_3R_VarDeclaration_290_4_10()) return true;
    return false;
  }

  private boolean jj_3R_Expression_663_22_17()
 {
    if (jj_3R_Identifier_739_4_15()) return true;
    return false;
  }

  private boolean jj_3R_Expression_625_10_27()
 {
    if (jj_scan_token(37)) return true;
    return false;
  }

  private boolean jj_3R_Expression_660_22_16()
 {
    if (jj_scan_token(LENGTH)) return true;
    return false;
  }

  private boolean jj_3R_Expression_577_10_22()
 {
    if (jj_scan_token(NEW)) return true;
    return false;
  }

  private boolean jj_3R_Expression_622_10_26()
 {
    if (jj_scan_token(THIS)) return true;
    return false;
  }

  private boolean jj_3R_Expression_712_13_13()
 {
    if (jj_scan_token(OPERATOR)) return true;
    if (jj_3R_Expression_575_4_18()) return true;
    return false;
  }

  private boolean jj_3R_Expression_619_10_25()
 {
    if (jj_3R_Identifier_739_4_15()) return true;
    return false;
  }

  private boolean jj_3R_Expression_575_4_18()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_Expression_577_10_22()) {
    jj_scanpos = xsp;
    if (jj_3R_Expression_613_10_23()) {
    jj_scanpos = xsp;
    if (jj_3R_Expression_616_10_24()) {
    jj_scanpos = xsp;
    if (jj_3R_Expression_619_10_25()) {
    jj_scanpos = xsp;
    if (jj_3R_Expression_622_10_26()) {
    jj_scanpos = xsp;
    if (jj_3R_Expression_625_10_27()) {
    jj_scanpos = xsp;
    if (jj_3R_Expression_635_10_28()) return true;
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_Expression_616_10_24()
 {
    if (jj_scan_token(BOOLEAN_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_Type_337_7_21()
 {
    if (jj_3R_Identifier_739_4_15()) return true;
    return false;
  }

  private boolean jj_3R_Expression_613_10_23()
 {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_VarDeclaration_290_4_10()
 {
    if (jj_3R_Type_316_4_14()) return true;
    if (jj_3R_Identifier_739_4_15()) return true;
    return false;
  }

  private boolean jj_3R_Type_334_7_20()
 {
    if (jj_scan_token(TYPE_BOOL)) return true;
    return false;
  }

  private boolean jj_3R_Expression_654_13_11()
 {
    if (jj_scan_token(38)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_Expression_660_22_16()) {
    jj_scanpos = xsp;
    if (jj_3R_Expression_663_22_17()) return true;
    }
    return false;
  }

  private boolean jj_3R_Expression_700_13_12()
 {
    if (jj_scan_token(32)) return true;
    if (jj_3R_Expression_575_4_18()) return true;
    return false;
  }

  private boolean jj_3R_Type_322_13_29()
 {
    if (jj_scan_token(32)) return true;
    return false;
  }

  /** Generated Token Manager. */
  public MiniJavaParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[18];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
	   jj_la1_init_0();
	   jj_la1_init_1();
	}
	private static void jj_la1_init_0() {
	   jj_la1_0 = new int[] {0x80,0x20000,0x8c000000,0x100,0x0,0x8c000000,0x80684000,0x0,0x8c000000,0x80684000,0x0,0x80684000,0x84000000,0xb3001000,0x0,0xb3001000,0x80800000,0x40000000,};
	}
	private static void jj_la1_init_1() {
	   jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x1,0x0,0x0,0x1,0x0,0x0,0x20,0x4,0x20,0x0,0x41,};
	}
  final private JJCalls[] jj_2_rtns = new JJCalls[2];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public MiniJavaParser(java.io.InputStream stream) {
	  this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public MiniJavaParser(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source = new MiniJavaParserTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 18; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
	  ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 18; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public MiniJavaParser(java.io.Reader stream) {
	 jj_input_stream = new SimpleCharStream(stream, 1, 1);
	 token_source = new MiniJavaParserTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 18; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
	if (jj_input_stream == null) {
	   jj_input_stream = new SimpleCharStream(stream, 1, 1);
	} else {
	   jj_input_stream.ReInit(stream, 1, 1);
	}
	if (token_source == null) {
 token_source = new MiniJavaParserTokenManager(jj_input_stream);
	}

	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 18; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public MiniJavaParser(MiniJavaParserTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 18; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(MiniJavaParserTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 18; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
	 Token oldToken;
	 if ((oldToken = token).next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 if (token.kind == kind) {
	   jj_gen++;
	   if (++jj_gc > 100) {
		 jj_gc = 0;
		 for (int i = 0; i < jj_2_rtns.length; i++) {
		   JJCalls c = jj_2_rtns[i];
		   while (c != null) {
			 if (c.gen < jj_gen) c.first = null;
			 c = c.next;
		   }
		 }
	   }
	   return token;
	 }
	 token = oldToken;
	 jj_kind = kind;
	 throw generateParseException();
  }

  @SuppressWarnings("serial")
  static private final class LookaheadSuccess extends java.lang.Error {
    @Override
    public Throwable fillInStackTrace() {
      return this;
    }
  }
  static private final LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
	 if (jj_scanpos == jj_lastpos) {
	   jj_la--;
	   if (jj_scanpos.next == null) {
		 jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
	   } else {
		 jj_lastpos = jj_scanpos = jj_scanpos.next;
	   }
	 } else {
	   jj_scanpos = jj_scanpos.next;
	 }
	 if (jj_rescan) {
	   int i = 0; Token tok = token;
	   while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
	   if (tok != null) jj_add_error_token(kind, i);
	 }
	 if (jj_scanpos.kind != kind) return true;
	 if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
	 return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
	 if (token.next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 jj_gen++;
	 return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
	 Token t = token;
	 for (int i = 0; i < index; i++) {
	   if (t.next != null) t = t.next;
	   else t = t.next = token_source.getNextToken();
	 }
	 return t;
  }

  private int jj_ntk_f() {
	 if ((jj_nt=token.next) == null)
	   return (jj_ntk = (token.next=token_source.getNextToken()).kind);
	 else
	   return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
	 if (pos >= 100) {
		return;
	 }

	 if (pos == jj_endpos + 1) {
	   jj_lasttokens[jj_endpos++] = kind;
	 } else if (jj_endpos != 0) {
	   jj_expentry = new int[jj_endpos];

	   for (int i = 0; i < jj_endpos; i++) {
		 jj_expentry[i] = jj_lasttokens[i];
	   }

	   for (int[] oldentry : jj_expentries) {
		 if (oldentry.length == jj_expentry.length) {
		   boolean isMatched = true;

		   for (int i = 0; i < jj_expentry.length; i++) {
			 if (oldentry[i] != jj_expentry[i]) {
			   isMatched = false;
			   break;
			 }

		   }
		   if (isMatched) {
			 jj_expentries.add(jj_expentry);
			 break;
		   }
		 }
	   }

	   if (pos != 0) {
		 jj_lasttokens[(jj_endpos = pos) - 1] = kind;
	   }
	 }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
	 jj_expentries.clear();
	 boolean[] la1tokens = new boolean[39];
	 if (jj_kind >= 0) {
	   la1tokens[jj_kind] = true;
	   jj_kind = -1;
	 }
	 for (int i = 0; i < 18; i++) {
	   if (jj_la1[i] == jj_gen) {
		 for (int j = 0; j < 32; j++) {
		   if ((jj_la1_0[i] & (1<<j)) != 0) {
			 la1tokens[j] = true;
		   }
		   if ((jj_la1_1[i] & (1<<j)) != 0) {
			 la1tokens[32+j] = true;
		   }
		 }
	   }
	 }
	 for (int i = 0; i < 39; i++) {
	   if (la1tokens[i]) {
		 jj_expentry = new int[1];
		 jj_expentry[0] = i;
		 jj_expentries.add(jj_expentry);
	   }
	 }
	 jj_endpos = 0;
	 jj_rescan_token();
	 jj_add_error_token(0, 0);
	 int[][] exptokseq = new int[jj_expentries.size()][];
	 for (int i = 0; i < jj_expentries.size(); i++) {
	   exptokseq[i] = jj_expentries.get(i);
	 }
	 return new ParseException(token, exptokseq, tokenImage);
  }

  private boolean trace_enabled;

/** Trace enabled. */
  final public boolean trace_enabled() {
	 return trace_enabled;
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
	 jj_rescan = true;
	 for (int i = 0; i < 2; i++) {
	   try {
		 JJCalls p = jj_2_rtns[i];

		 do {
		   if (p.gen > jj_gen) {
			 jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
			 switch (i) {
			   case 0: jj_3_1(); break;
			   case 1: jj_3_2(); break;
			 }
		   }
		   p = p.next;
		 } while (p != null);

		 } catch(LookaheadSuccess ls) { }
	 }
	 jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
	 JJCalls p = jj_2_rtns[index];
	 while (p.gen > jj_gen) {
	   if (p.next == null) { p = p.next = new JJCalls(); break; }
	   p = p.next;
	 }

	 p.gen = jj_gen + xla - jj_la; 
	 p.first = token;
	 p.arg = xla;
  }

  static final class JJCalls {
	 int gen;
	 Token first;
	 int arg;
	 JJCalls next;
  }

}

class JTBToolkit {
   static NodeToken makeNodeToken(Token t) {
      return new NodeToken(t.image.intern(), t.kind, t.beginLine, t.beginColumn, t.endLine, t.endColumn);
   }
}
