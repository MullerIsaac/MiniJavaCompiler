options {
  STATIC = false; 
}

PARSER_BEGIN(MiniJavaParser)
public class MiniJavaParser {
}

PARSER_END(MiniJavaParser)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
|  <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
|  <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}

TOKEN :
{
  <CLASS: "class">
| <PUBLIC: "public">
| <STATIC: "static">
| <VOID: "void">
| <MAIN: "main">
| <LPAREN: "(">
| <RPAREN: ")">
| <LBRACE: "{">
| <RBRACE: "}">
| <STRING: "String">
| <EXTENDS: "extends">
| <RETURN: "return">
| <IF: "if">
| <ELSE: "else">
| <WHILE: "while">
| <PRINT: "System.out.println">
| <LENGTH: "length">
| <NEW: "new">
| <THIS: "this">
| <TYPE_INT: "int">
| <TYPE_BOOL: "boolean">
| <INTEGER_LITERAL: (["0"-"9"])+>
| <BOOLEAN_LITERAL: "true"|"false">
| <OPERATOR: "&&"|"<"|"+"|"-"|"*">
| <IDENTIFIER: ["a"-"z","A"-"Z"](["a"-"z","A"-"Z","0"-"9", "_"])*>
}

void Goal():
{}
{
  MainClass()
  (ClassDeclaration())*
  <EOF>
}

void MainClass():
{}
{
  <CLASS> Identifier()
  <LBRACE>
    <PUBLIC> <STATIC> <VOID> <MAIN> <LPAREN> <STRING> "[" "]" Identifier() <RPAREN>
    <LBRACE>
       Statement()
    <RBRACE> 
  <RBRACE> 
}

void ClassDeclaration():
{}
{
  <CLASS> Identifier() [<EXTENDS> Identifier()]
  <LBRACE>
    (VarDeclaration())*
    (MethodDeclaration())*
  <RBRACE>
}

void MethodDeclaration():
{}
{
  <PUBLIC> Type() Identifier() <LPAREN>  [Type() Identifier() ("," Type() Identifier())*] <RPAREN>
  <LBRACE> 
    (LOOKAHEAD(2) VarDeclaration())*
    (Statement())*
    <RETURN> Expression() ";"
  <RBRACE> 
}

void VarDeclaration():
{}
{
  Type() Identifier() ";"  
}

void Type():
{}
{
  (<TYPE_INT> ["[" "]"])
| <TYPE_BOOL>
| Identifier()
}

void Statement():
{}
{
  (<LBRACE>  (Statement())* <RBRACE>)
| (<IF> <LPAREN> Expression() <RPAREN> Statement() <ELSE> Statement())
| (<WHILE> <LPAREN> Expression() <RPAREN>  Statement())
| (<PRINT> <LPAREN> Expression() <RPAREN>  ";")
| (Identifier() ["[" Expression() "]"] "=" Expression() ";")
}

void Expression():
{}
{
  (
      <NEW> ((<TYPE_INT> "[" Expression() "]")|(Identifier() <LPAREN> <RPAREN>))
    | <INTEGER_LITERAL>
    | <BOOLEAN_LITERAL>
    | Identifier()
    | <THIS>
    | ("!" Expression())
    | (<LPAREN> Expression() <RPAREN>)
  )
  ( 
    LOOKAHEAD(2) 
    ( 
        ("." (<LENGTH>|(Identifier() <LPAREN>  [Expression() ("," Expression())*] <RPAREN>)))
      | ("[" Expression() "]")
      | (<OPERATOR> Expression())
    )
  )*
}

void Identifier():
{}
{
  <IDENTIFIER>
}
